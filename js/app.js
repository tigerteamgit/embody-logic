/* ---- PWA / Service Worker ---- */
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("service-worker.js");
}

/* ---- Access Gate (Preview allowed) ---- */
const ACCESS_TOKEN = "123TTR"; // change this
const params = new URLSearchParams(window.location.search);
const isUnlocked = params.get("access") === ACCESS_TOKEN;

/* ---- Toggle Full Access UI ---- */
const fullAccessCard = document.getElementById("fullAccessCard");
if (fullAccessCard && isUnlocked) {
  fullAccessCard.style.display = "block";
}

/*--------------------------------------------------------------*/

/* ---- Creative Expansion Lab: app.js ---- */
/* Build stamp (change this line to force a visible diff in commits): 2026-02-27-02 */

/* ---- App bootstrap ---- */
(() => {
  "use strict";

  document.addEventListener("DOMContentLoaded", () => {

    /* ---- Storage ---- */
    const STORAGE_KEY = "cel_attempts_v1";

    /* ---- Helpers ---- */
    function val(id){ const el=document.getElementById(id); return el ? el.value.trim() : ""; }
    function num(id){
      const el=document.getElementById(id);
      if(!el) return null;
      const v = el.value === "" ? null : Number(el.value);
      return Number.isFinite(v) ? v : null;
    }
    function escapeHtml(s){
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;");
    }
    function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
    function fmtTime(sec){
      const m = Math.floor(sec/60);
      const s = sec%60;
      return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
    }

    /* ---- Round definitions (Somatic first) ---- */
    const ROUNDS = [
      {
        id: "somatic",
        title: "Round 1 — Somatic Expansion (Body → Mind)",
        desc: "No equipment. Self-timed. Enter results. Same protocol for Baseline + Post.",
        timedSeconds: 0,
        render: (state) => `
          <div class="notice"><strong>Instructions:</strong> Do each test safely. Use a phone timer if needed. Enter honest results.</div>

          <h3 style="margin-top:10px;">Test 1 — Forward Fold Reach (0–20)</h3>
          <label>Select your best match</label>
          <select id="s1_fold">
            <option value="">Select…</option>
            <option value="0"  ${state.s1_fold==0  ? "selected":""}>0 — Hands above knees</option>
            <option value="5"  ${state.s1_fold==5  ? "selected":""}>5 — Fingertips to shins</option>
            <option value="10" ${state.s1_fold==10 ? "selected":""}>10 — Fingertips to ankles</option>
            <option value="15" ${state.s1_fold==15 ? "selected":""}>15 — Touch toes</option>
            <option value="20" ${state.s1_fold==20 ? "selected":""}>20 — Palms flat on floor</option>
          </select>

          <div class="hr"></div>

          <h3>Test 2 — Cross-Body Coordination (30 sec)</h3>
          <p class="muted">Opposite elbow to knee, alternating, for 30 seconds. Count smooth reps.</p>
          <label>Reps in 30 seconds</label>
          <input id="s2_reps" type="number" min="0" max="200" value="${state.s2_reps ?? ""}" placeholder="e.g., 18" />

          <div class="hr"></div>

          <h3>Test 3 — Balance (Eyes closed)</h3>
          <p class="muted">Single leg, eyes closed. Time until you step/wobble out.</p>
          <label>Seconds held</label>
          <input id="s3_balance_sec" type="number" min="0" max="300" value="${state.s3_balance_sec ?? ""}" placeholder="e.g., 12" />

          <div class="hr"></div>

          <h3>Test 4 — Recovery (15 squats)</h3>
          <p class="muted">Do 15 bodyweight squats. Time until your breathing feels calm again.</p>
          <label>Seconds to calm breathing</label>
          <input id="s4_recovery_sec" type="number" min="0" max="600" value="${state.s4_recovery_sec ?? ""}" placeholder="e.g., 55" />
        `,
        collect: (state) => {
          const fold = document.getElementById("s1_fold")?.value;
          state.s1_fold = fold === "" ? null : Number(fold);
          state.s2_reps = num("s2_reps");
          state.s3_balance_sec = num("s3_balance_sec");
          state.s4_recovery_sec = num("s4_recovery_sec");
        }
      },
      {
        id: "divergence",
        title: "Round 2 — Divergence Sprint (Raw Range)",
        desc: "5 minutes. List uses / meanings / metaphors. Speed > polish.",
        timedSeconds: 5 * 60,
        render: (state) => `
          <div class="notice"><strong>Rules:</strong> One idea per line. Don’t censor. Keep moving.</div>

          <label>Water — uses / meanings (one per line)</label>
          <textarea id="r1_water" placeholder="e.g., currency, memory, cooling system, ritual...">${escapeHtml(state.r1_water || "")}</textarea>

          <label>Rock — uses / meanings (one per line)</label>
          <textarea id="r1_rock" placeholder="e.g., foundation, percussion, obstacle, signal...">${escapeHtml(state.r1_rock || "")}</textarea>

          <label>Light — uses / meanings (one per line)</label>
          <textarea id="r1_light" placeholder="e.g., navigation, truth, growth cue, encryption...">${escapeHtml(state.r1_light || "")}</textarea>

          <div class="row">
            <div>
              <label>Category count (0–10+)</label>
              <input id="r1_categories" type="number" min="0" max="20" value="${state.r1_categories ?? ""}" placeholder="e.g., 8" />
              <div class="muted" style="font-size:12px;margin-top:6px;">
                Examples: physical, emotional, scientific, cultural, symbolic, functional, narrative, systemic, philosophical…
              </div>
            </div>
            <div>
              <label>Most unusual idea (copy/paste one line)</label>
              <input id="r1_unusual" type="text" value="${escapeHtml(state.r1_unusual || "")}" placeholder="e.g., Light as 'error-correcting code'"/>
            </div>
          </div>
        `,
        collect: (state) => {
          state.r1_water = val("r1_water");
          state.r1_rock = val("r1_rock");
          state.r1_light = val("r1_light");
          state.r1_categories = num("r1_categories");
          state.r1_unusual = val("r1_unusual");
        }
      },
      {
        id: "forced_connection",
        title: "Round 3 — Forced Connection Engine",
        desc: "Connect three words into one idea. Then score it with the rubric.",
        timedSeconds: 5 * 60,
        render: (state) => `
          <div class="notice"><strong>Your words:</strong> Ocean • Clock • Thread</div>
          <label>Write a paragraph connecting all three</label>
          <textarea id="r2_text" placeholder="Write 6–10 lines...">${escapeHtml(state.r2_text || "")}</textarea>

          <div class="row">
            <div>
              <label>Coherence (1–5)</label>
              <input id="r2_coherence" type="number" min="1" max="5" value="${state.r2_coherence ?? ""}" />
            </div>
            <div>
              <label>Originality (1–5)</label>
              <input id="r2_originality" type="number" min="1" max="5" value="${state.r2_originality ?? ""}" />
            </div>
            <div>
              <label>Depth (1–5)</label>
              <input id="r2_depth" type="number" min="1" max="5" value="${state.r2_depth ?? ""}" />
            </div>
          </div>

          <div class="muted" style="font-size:12px;">
            Rubric: Coherence = it makes sense; Originality = not cliché; Depth = layers, implications, metaphor, mechanism.
          </div>
        `,
        collect: (state) => {
          state.r2_text = val("r2_text");
          state.r2_coherence = num("r2_coherence");
          state.r2_originality = num("r2_originality");
          state.r2_depth = num("r2_depth");
        }
      },
      {
        id: "perspective_shift",
        title: "Round 4 — Perspective Shift Drill",
        desc: "Argue both sides. 3 FOR and 3 AGAINST. Then score your balance + nuance.",
        timedSeconds: 5 * 60,
        render: (state) => `
          <div class="notice"><strong>Claim:</strong> “Constraints increase creativity.”</div>

          <label>FOR — 3 arguments (one per line)</label>
          <textarea id="r3_for" placeholder="1) ...&#10;2) ...&#10;3) ...">${escapeHtml(state.r3_for || "")}</textarea>

          <label>AGAINST — 3 arguments (one per line)</label>
          <textarea id="r3_against" placeholder="1) ...&#10;2) ...&#10;3) ...">${escapeHtml(state.r3_against || "")}</textarea>

          <div class="row">
            <div>
              <label>Symmetry (1–5)</label>
              <input id="r3_symmetry" type="number" min="1" max="5" value="${state.r3_symmetry ?? ""}" />
            </div>
            <div>
              <label>Nuance (1–5)</label>
              <input id="r3_nuance" type="number" min="1" max="5" value="${state.r3_nuance ?? ""}" />
            </div>
            <div>
              <label>Non-redundancy (1–5)</label>
              <input id="r3_unique" type="number" min="1" max="5" value="${state.r3_unique ?? ""}" />
            </div>
          </div>
        `,
        collect: (state) => {
          state.r3_for = val("r3_for");
          state.r3_against = val("r3_against");
          state.r3_symmetry = num("r3_symmetry");
          state.r3_nuance = num("r3_nuance");
          state.r3_unique = num("r3_unique");
        }
      },
      {
        id: "ambiguity",
        title: "Round 5 — Ambiguity Field",
        desc: "Answer a vague prompt. Then rate your comfort and your urge to resolve.",
        timedSeconds: 4 * 60,
        render: (state) => `
          <div class="notice"><strong>Prompt:</strong> Gravity is half as strong tomorrow. What changes, and what new industries appear?</div>
          <label>Your response</label>
          <textarea id="r4_text" placeholder="Write freely...">${escapeHtml(state.r4_text || "")}</textarea>

          <div class="row">
            <div>
              <label>Comfort in uncertainty (1–10)</label>
              <input id="r4_comfort" type="number" min="1" max="10" value="${state.r4_comfort ?? ""}" />
            </div>
            <div>
              <label>Urge to resolve quickly (1–10)</label>
              <input id="r4_urge" type="number" min="1" max="10" value="${state.r4_urge ?? ""}" />
            </div>
          </div>
        `,
        collect: (state) => {
          state.r4_text = val("r4_text");
          state.r4_comfort = num("r4_comfort");
          state.r4_urge = num("r4_urge");
        }
      },
      {
        id: "complexity",
        title: "Round 6 — Complexity Handling",
        desc: "Design a system. Score how many variables and feedback loops you included.",
        timedSeconds: 6 * 60,
        render: (state) => `
          <div class="notice"><strong>Challenge:</strong> Design a system that helps a city reduce traffic without building new roads.</div>
          <label>Your system sketch (text)</label>
          <textarea id="r5_text" placeholder="Include constraints, incentives, feedback loops, unintended consequences...">${escapeHtml(state.r5_text || "")}</textarea>

          <div class="row">
            <div>
              <label>Variables considered (0–20)</label>
              <input id="r5_vars" type="number" min="0" max="50" value="${state.r5_vars ?? ""}" placeholder="e.g., 9" />
            </div>
            <div>
              <label>Feedback loops / second-order effects (0–10)</label>
              <input id="r5_loops" type="number" min="0" max="20" value="${state.r5_loops ?? ""}" placeholder="e.g., 3" />
            </div>
          </div>

          <div class="row">
            <div>
              <label>Clarity (1–5)</label>
              <input id="r5_clarity" type="number" min="1" max="5" value="${state.r5_clarity ?? ""}" />
            </div>
            <div>
              <label>Originality (1–5)</label>
              <input id="r5_originality" type="number" min="1" max="5" value="${state.r5_originality ?? ""}" />
            </div>
            <div>
              <label>Depth (1–5)</label>
              <input id="r5_depth" type="number" min="1" max="5" value="${state.r5_depth ?? ""}" />
            </div>
          </div>
        `,
        collect: (state) => {
          state.r5_text = val("r5_text");
          state.r5_vars = num("r5_vars");
          state.r5_loops = num("r5_loops");
          state.r5_clarity = num("r5_clarity");
          state.r5_originality = num("r5_originality");
          state.r5_depth = num("r5_depth");
        }
      }
    ];

    /* ---- App state ---- */
    const state = {
      attemptType: "baseline",
      displayName: "",
      startedAt: null,
      finishedAt: null,

      /* Manual Active Timer (start/stop anytime) */
      activeSeconds: 0,
      _activeRunning: false,
      _activeStartedAtMs: null,
      _activeIntervalId: null,

      roundIndex: 0,

      /* Keep the round countdown timer object (still used if you want it) */
      timer: { running:false, endAt: null, intervalId: null },
    };

    /* ---- DOM ---- */
    const introCard = document.getElementById("introCard");
    const labCard = document.getElementById("labCard");
    const resultsCard = document.getElementById("resultsCard");
    const roundTitle = document.getElementById("roundTitle");
    const roundDesc = document.getElementById("roundDesc");
    const roundBody = document.getElementById("roundBody");
    const timerPill = document.getElementById("timerPill");
    const progressBar = document.getElementById("progressBar");
    const stepLabel = document.getElementById("stepLabel");
    const modeLabel = document.getElementById("modeLabel");
    const nextBtn = document.getElementById("nextBtn");

    /* Manual timer buttons (must exist in cel.html) */
    const timerStartBtn = document.getElementById("timerStartBtn");
    const timerStopBtn  = document.getElementById("timerStopBtn");
    const timerResetBtn = document.getElementById("timerResetBtn");

    /* ---- Charts State ---- */
    let creativeChartInstance = null;
    let somaticChartInstance = null;

    function destroyCharts(){
      if(creativeChartInstance){ creativeChartInstance.destroy(); creativeChartInstance = null; }
      if(somaticChartInstance){ somaticChartInstance.destroy(); somaticChartInstance = null; }
    }

    /* ---- Chart polish helpers (darker = higher value) ---- */
    function normalizeValues(values){
      const nums = values.map(v => Number(v) || 0);
      const min = Math.min(...nums);
      const max = Math.max(...nums);
      const span = max - min;
      if(span <= 0) return nums.map(() => 0.5);
      return nums.map(v => (v - min) / span);
    }

    function blackByValue(values){
      const t = normalizeValues(values);
      const lightLow = 62;
      const lightHigh = 10;
      return t.map(x => `hsl(0, 0%, ${Math.round(lightLow + (lightHigh - lightLow) * x)}%)`);
    }

    function blueByValue(values){
      const t = normalizeValues(values);
      const hue = 210;
      const sat = 78;
      const lightLow = 72;
      const lightHigh = 26;
      return t.map(x => `hsl(${hue}, ${sat}%, ${Math.round(lightLow + (lightHigh - lightLow) * x)}%)`);
    }

    function findMaxIndex(values){
      let maxIdx = 0;
      for(let i = 1; i < values.length; i++){
        if((Number(values[i]) || 0) > (Number(values[maxIdx]) || 0)) maxIdx = i;
      }
      return maxIdx;
    }

    function applyPolish(chart, rampFn){
      const ds = chart.data.datasets[0];
      const vals = ds.data.map(v => Number(v) || 0);
      const colors = rampFn(vals);
      const maxIdx = findMaxIndex(vals);

      const maxBoost = colors[maxIdx].startsWith("hsl(0, 0%")
        ? "hsl(0, 0%, 6%)"
        : "hsl(210, 82%, 22%)";

      ds.backgroundColor = colors;
      ds.borderColor = colors.map((c, i) => (i === maxIdx ? maxBoost : c));
      ds.borderWidth = vals.map((_, i) => (i === maxIdx ? 2 : 1));
      ds.borderRadius = 6;
      ds.borderSkipped = false;
      ds.barPercentage = 0.78;
      ds.categoryPercentage = 0.86;
      ds.hoverBackgroundColor = colors.map((c, i) => (i === maxIdx ? maxBoost : c));
      ds.hoverBorderWidth = vals.map((_, i) => (i === maxIdx ? 3 : 2));
    }

    function renderCharts(attempt){
      if(typeof window.Chart === "undefined") return;

      const creativeCanvas = document.getElementById("creativeChart");
      const somaticCanvas = document.getElementById("somaticChart");
      if(!creativeCanvas || !somaticCanvas) return;

      destroyCharts();

      const creativeValues = [
        attempt.scores.cei ?? 0,
        attempt.scores.fluency ?? 0,
        attempt.scores.flexibility ?? 0,
        attempt.scores.associative ?? 0,
        attempt.scores.perspective ?? 0,
        attempt.scores.ambiguity ?? 0,
        attempt.scores.complexity ?? 0
      ];

      const somaticValues = [
        attempt.scores.sei ?? 0,
        attempt.scores.ees ?? 0,
        attempt.scores.somatic_range ?? 0,
        attempt.scores.somatic_recovery ?? 0,
        attempt.scores.gap ?? 0
      ];

      const baseOptions = {
        responsive: true,
        maintainAspectRatio: false,
        animation: { duration: 260, easing: "easeOutQuart" },
        plugins: {
          legend: { display: false },
          tooltip: {
            enabled: true,
            displayColors: false,
            callbacks: { label: (ctx) => `${ctx.label}: ${ctx.parsed.y}` }
          }
        },
        interaction: { mode: "nearest", intersect: false },
        scales: {
          y: { beginAtZero: true, max: 100, ticks: { maxTicksLimit: 5 } },
          x: { ticks: { autoSkip: false, maxRotation: 25, minRotation: 25 } }
        }
      };

      somaticChartInstance = new Chart(somaticCanvas, {
        type: "bar",
        data: {
          labels: ["Somatic Index","Embodied Expansion","Range","Recovery","Integration Gap"],
          datasets: [{ label: "Somatic Scores", data: somaticValues }]
        },
        options: baseOptions
      });

      creativeChartInstance = new Chart(creativeCanvas, {
        type: "bar",
        data: {
          labels: ["Creative Index","Fluency","Flexibility","Associative Strength","Perspective Shift","Ambiguity Tolerance","Complexity Handling"],
          datasets: [{ label: "Creative Scores", data: creativeValues }]
        },
        options: baseOptions
      });

      const forcePolish = () => {
        if(!somaticChartInstance || !creativeChartInstance) return;
        applyPolish(somaticChartInstance, blackByValue);
        applyPolish(creativeChartInstance, blueByValue);
        somaticChartInstance.update();
        creativeChartInstance.update();
      };

      forcePolish();
      requestAnimationFrame(forcePolish);
      setTimeout(forcePolish, 0);
      setTimeout(forcePolish, 50);
    }

    /* ---- Bulletproof: Next can NEVER be disabled (no loops) ---- */
    function unlockNext(){
      if(!nextBtn) return;
      nextBtn.disabled = false;
      nextBtn.removeAttribute("disabled");
    }
    unlockNext();
    new MutationObserver(() => unlockNext())
      .observe(nextBtn, { attributes: true, attributeFilter: ["disabled"] });

    /* ---- Progress ---- */
    function setProgress(){
      const totalSteps = ROUNDS.length + 1;
      const step = state.roundIndex + 1;
      progressBar.style.width = `${Math.round((step/totalSteps)*100)}%`;
      stepLabel.textContent = `Round ${state.roundIndex+1} of ${ROUNDS.length}`;
      modeLabel.textContent = `Mode: ${state.attemptType === "baseline" ? "Baseline" : "Post"}`;
    }

    /* ---- Manual Active Timer (start/stop anytime) ---- */
    function setTimerButtons(){
      if(!timerStartBtn || !timerStopBtn) return;
      timerStartBtn.disabled = !!state._activeRunning;
      timerStopBtn.disabled  = !state._activeRunning;
    }

    function renderActiveTimerPill(){
      if(!timerPill) return;

      let total = state.activeSeconds || 0;
      if(state._activeRunning && state._activeStartedAtMs){
        const extra = Math.floor((Date.now() - state._activeStartedAtMs) / 1000);
        total += Math.max(0, extra);
      }
      timerPill.textContent = `Timer: ${fmtTime(total)}`;
    }

    function startActiveTimer(){
      if(state._activeRunning) return;
      state._activeRunning = true;
      state._activeStartedAtMs = Date.now();

      if(state._activeIntervalId) clearInterval(state._activeIntervalId);
      state._activeIntervalId = setInterval(renderActiveTimerPill, 250);

      setTimerButtons();
      renderActiveTimerPill();
    }

    function stopActiveTimer(){
      if(!state._activeRunning) return;

      const extra = state._activeStartedAtMs
        ? Math.floor((Date.now() - state._activeStartedAtMs) / 1000)
        : 0;

      state.activeSeconds = (state.activeSeconds || 0) + Math.max(0, extra);

      state._activeRunning = false;
      state._activeStartedAtMs = null;

      if(state._activeIntervalId) clearInterval(state._activeIntervalId);
      state._activeIntervalId = null;

      setTimerButtons();
      renderActiveTimerPill();
    }

    function resetActiveTimer(){
      state.activeSeconds = 0;
      state._activeRunning = false;
      state._activeStartedAtMs = null;

      if(state._activeIntervalId) clearInterval(state._activeIntervalId);
      state._activeIntervalId = null;

      setTimerButtons();
      renderActiveTimerPill();
    }

    /* ---- Round Countdown Timer (kept; DOES NOT drive the pill anymore) ---- */
    function startTimer(seconds){
      stopTimer();

      if(!seconds || seconds <= 0) return;

      state.timer.running = true;
      const now = Date.now();
      state.timer.endAt = now + seconds*1000;

      state.timer.intervalId = setInterval(() => {
        const leftMs = state.timer.endAt - Date.now();
        const left = Math.max(0, Math.ceil(leftMs/1000));
        if(left <= 0){
          stopTimer();
        }
      }, 250);
    }

    function stopTimer(){
      if(state.timer.intervalId) clearInterval(state.timer.intervalId);
      state.timer.intervalId = null;
      state.timer.running = false;
    }

    /* ---- Navigation ---- */
    function showIntro(){
      stopTimer();
      destroyCharts();
      introCard.style.display = "block";
      labCard.style.display = "none";
      resultsCard.style.display = "none";

      progressBar.style.width = "0%";
      stepLabel.textContent = "Step";
      modeLabel.textContent = `Mode: ${state.attemptType === "baseline" ? "Baseline" : "Post"}`;

      setTimerButtons();
      renderActiveTimerPill();
    }

    function showLab(){
      introCard.style.display = "none";
      labCard.style.display = "block";
      resultsCard.style.display = "none";
      destroyCharts();
      unlockNext();

      setTimerButtons();
      renderActiveTimerPill();
    }

    function showResults(attempt){
      introCard.style.display = "none";
      labCard.style.display = "none";
      resultsCard.style.display = "block";

      /* Visible totals (2 cards) */
      document.getElementById("seiTotalN").textContent = attempt.scores.sei ?? "—";
      document.getElementById("ceiTotalN").textContent = attempt.scores.cei ?? "—";

      /* Legacy KPI values (kept for future UI; hidden now) */
      document.getElementById("ceiN").textContent = attempt.scores.cei ?? "—";
      document.getElementById("fluencyN").textContent = attempt.scores.fluency ?? "—";
      document.getElementById("flexN").textContent = attempt.scores.flexibility ?? "—";
      document.getElementById("assocN").textContent = attempt.scores.associative ?? "—";
      document.getElementById("shiftN").textContent = attempt.scores.perspective ?? "—";
      document.getElementById("ambN").textContent = attempt.scores.ambiguity ?? "—";
      document.getElementById("complexN").textContent = attempt.scores.complexity ?? "—";

      document.getElementById("totalIdeasN").textContent = attempt.scores.ideaCount ?? "—";
      document.getElementById("catsN").textContent = attempt.scores.categoryCount ?? "—";
      document.getElementById("timeN").textContent = fmtTime(attempt.meta.activeSeconds ?? 0);

      document.getElementById("seiN").textContent = attempt.scores.sei ?? "—";
      document.getElementById("eesN").textContent = attempt.scores.ees ?? "—";
      document.getElementById("gapN").textContent = attempt.scores.gap ?? "—";
      document.getElementById("rangeN").textContent = attempt.scores.somatic_range ?? "—";
      document.getElementById("recoveryN").textContent = attempt.scores.somatic_recovery ?? "—";

      renderComparison(attempt);

      /* Render charts ONLY on Results screen */
      requestAnimationFrame(() => renderCharts(attempt));

      setTimerButtons();
      renderActiveTimerPill();
    }

    /* ---- Start / Reset ---- */
    function startLab(){
      state.attemptType = document.getElementById("attemptType").value;
      state.displayName = document.getElementById("displayName").value.trim();
      state.startedAt = new Date().toISOString();
      state.finishedAt = null;

      /* Reset manual timer for new attempt (do NOT auto-start) */
      resetActiveTimer();

      state.roundIndex = 0;

      showLab();
      renderRound();
    }

    function resetAttempt(clearName){
      stopTimer();
      resetActiveTimer();

      for (const key of Object.keys(state)) {
        if (key.startsWith("r") || key.startsWith("s")) delete state[key];
      }
      state.startedAt = null;
      state.finishedAt = null;
      state.roundIndex = 0;
      if(clearName) state.displayName = "";

      setTimerButtons();
      renderActiveTimerPill();
    }

    function resetAll(){
      if(!confirm("Reset all stored attempts on this device?")) return;
      localStorage.removeItem(STORAGE_KEY);
      alert("Local results cleared.");
    }

    function prevRound(){
      if(state.roundIndex <= 0) return;
      ROUNDS[state.roundIndex].collect(state);
      state.roundIndex -= 1;
      renderRound();
    }

    function nextRound(){
      if(state.roundIndex >= 0 && state.roundIndex < ROUNDS.length){
        ROUNDS[state.roundIndex].collect(state);
      }

      if(state.roundIndex < ROUNDS.length - 1){
        state.roundIndex += 1;
        renderRound();
      } else {
        finishAndScore();
      }
    }

    /* ---- Render ---- */
    function renderRound(){
      stopTimer();
      setProgress();

      const round = ROUNDS[state.roundIndex];
      roundTitle.textContent = round.title;
      roundDesc.textContent = round.desc;
      roundBody.innerHTML = round.render(state);

      unlockNext();

      /* Keep optional countdown running silently (no header changes) */
      startTimer(round.timedSeconds || 0);

      /* Header pill is manual timer */
      setTimerButtons();
      renderActiveTimerPill();
    }

    /* ---- Scoring ---- */
    function splitIdeas(text){
      return text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    }
    function scoreRound1Fluency(ideaCount){
      if(ideaCount <= 10) return 5;
      if(ideaCount <= 20) return 10;
      if(ideaCount <= 35) return 15;
      return 20;
    }
    function scoreRound1Flex(categories){
      const c = clamp(categories ?? 0, 0, 20);
      if(c <= 3) return 5;
      if(c <= 6) return 10;
      if(c <= 8) return 15;
      return 20;
    }
    function scoreRubric5(a,b,c){
      const A = clamp(a ?? 1, 1, 5);
      const B = clamp(b ?? 1, 1, 5);
      const C = clamp(c ?? 1, 1, 5);
      const sum = A+B+C;
      const norm = (sum - 3) / 12;
      return Math.round(norm * 20);
    }
    function scoreAmbiguity(comfort, urge){
      const c = clamp(comfort ?? 1, 1, 10);
      const u = clamp(urge ?? 10, 1, 10);
      const urgeRev = 11 - u;
      const avg = (c + urgeRev) / 2;
      return Math.round(((avg - 1) / 9) * 20);
    }
    function scoreComplexity(vars, loops, clarity, originality, depth){
      const v = clamp(vars ?? 0, 0, 20);
      const l = clamp(loops ?? 0, 0, 10);
      const vScore = (v / 20) * 10;
      const lScore = (l / 10) * 5;
      const rScore = (clamp(clarity ?? 1,1,5) + clamp(originality ?? 1,1,5) + clamp(depth ?? 1,1,5) - 3) / 12 * 5;
      return Math.round(clamp(vScore + lScore + rScore, 0, 20));
    }
    function scorePerspective(symmetry, nuance, unique){
      return scoreRubric5(symmetry, nuance, unique);
    }

    /* ---- Somatic scoring ---- */
    function scoreCoordination(reps){
      const r = clamp(reps ?? 0, 0, 200);
      if(r <= 10) return 5;
      if(r <= 20) return 10;
      if(r <= 30) return 15;
      return 20;
    }
    function scoreBalance(seconds){
      const s = clamp(seconds ?? 0, 0, 300);
      if(s <= 5) return 5;
      if(s <= 15) return 10;
      if(s <= 25) return 15;
      return 20;
    }
    function scoreRecovery(seconds){
      const s = clamp(seconds ?? 999, 0, 999);
      if(s > 90) return 5;
      if(s >= 60) return 10;
      if(s >= 30) return 15;
      return 20;
    }
    function scoreSomaticIndex(foldScore, reps, balanceSec, recoverySec){
      const range = clamp(foldScore ?? 0, 0, 20);
      const coordination = scoreCoordination(reps);
      const balance = scoreBalance(balanceSec);
      const recovery = scoreRecovery(recoverySec);

      const total80 = range + coordination + balance + recovery;
      const sei = Math.round((total80 / 80) * 100);
      return { sei, range, coordination, balance, recovery, total80 };
    }

    function finishAndScore(){
      stopTimer();
      state.finishedAt = new Date().toISOString();

      /* Capture any currently-running manual time */
      stopActiveTimer();
      const elapsedSec = state.activeSeconds || 0;

      const ideas = [
        ...splitIdeas(state.r1_water || ""),
        ...splitIdeas(state.r1_rock || ""),
        ...splitIdeas(state.r1_light || "")
      ];
      const ideaCount = ideas.length;
      const categoryCount = clamp(state.r1_categories ?? 0, 0, 20);

      const fluency = scoreRound1Fluency(ideaCount);
      const flexibility = scoreRound1Flex(categoryCount);

      const associative = scoreRubric5(state.r2_coherence, state.r2_originality, state.r2_depth);
      const perspective = scorePerspective(state.r3_symmetry, state.r3_nuance, state.r3_unique);
      const ambiguity = scoreAmbiguity(state.r4_comfort, state.r4_urge);
      const complexity = scoreComplexity(state.r5_vars, state.r5_loops, state.r5_clarity, state.r5_originality, state.r5_depth);

      const ambComplex = Math.round((ambiguity + complexity) / 2);
      const cei = fluency + flexibility + associative + perspective + ambComplex;

      const somatic = scoreSomaticIndex(state.s1_fold, state.s2_reps, state.s3_balance_sec, state.s4_recovery_sec);
      const ees = Math.round((cei + somatic.sei) / 2);
      const gap = Math.abs(cei - somatic.sei);

      const attempt = {
        id: cryptoRandomId(),
        meta: {
          attemptType: state.attemptType,
          displayName: state.displayName,
          startedAt: state.startedAt,
          finishedAt: state.finishedAt,
          activeSeconds: elapsedSec
        },
        inputs: { ...state },
        scores: {
          cei,
          fluency,
          flexibility,
          associative,
          perspective,
          ambiguity,
          complexity,
          ideaCount,
          categoryCount,
          sei: somatic.sei,
          ees,
          gap,
          somatic_range: somatic.range,
          somatic_coordination: somatic.coordination,
          somatic_balance: somatic.balance,
          somatic_recovery: somatic.recovery
        }
      };

      saveAttempt(attempt);
      showResults(attempt);
    }

    /* ---- Persistence ---- */
    function loadAttempts(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return [];
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch {
        return [];
      }
    }

    function saveAttempt(attempt){
      const attempts = loadAttempts();
      attempts.push(attempt);
      localStorage.setItem(STORAGE_KEY, JSON.stringify(attempts));
    }

    function showStoredResults(){
      const attempts = loadAttempts();
      if(attempts.length === 0){
        alert("No attempts stored on this device yet.");
        return;
      }
      showResults(attempts[attempts.length - 1]);
    }

    function renderComparison(current){
      const attempts = loadAttempts();
      const baseline = [...attempts].reverse().find(a => a.meta.attemptType === "baseline");
      const post = [...attempts].reverse().find(a => a.meta.attemptType === "post");

      const el = document.getElementById("comparisonBlock");
      if(!baseline || !post){
        el.innerHTML = `
          <div class="notice"><strong>Comparison:</strong> Take both a Baseline and a Post attempt on this device to see before/after deltas.</div>
        `;
        return;
      }

      const delta = post.scores.cei - baseline.scores.cei;
      const klass = delta >= 8 ? "good" : (delta >= 2 ? "warn" : (delta >= 0 ? "warn" : "bad"));

      const rows = [
        ["CEI", baseline.scores.cei, post.scores.cei],
        ["SEI", baseline.scores.sei, post.scores.sei],
        ["EES", baseline.scores.ees, post.scores.ees],
        ["Gap", baseline.scores.gap, post.scores.gap],
      ];

      el.innerHTML = `
        <div class="card" style="box-shadow:none;">
          <h3>Baseline vs Post (on this device)</h3>
          <p class="muted">Delta (CEI): <span class="${klass}">${delta >= 0 ? "+" : ""}${delta}</span></p>
          <div style="overflow:auto;">
            <table style="width:100%; border-collapse:collapse; font-size:14px;">
              <thead>
                <tr>
                  <th style="text-align:left; padding:10px;">Metric</th>
                  <th style="text-align:right; padding:10px;">Baseline</th>
                  <th style="text-align:right; padding:10px;">Post</th>
                  <th style="text-align:right; padding:10px;">Δ</th>
                </tr>
              </thead>
              <tbody>
                ${rows.map(([k,b,p]) => `
                  <tr>
                    <td style="padding:10px;">${k}</td>
                    <td style="padding:10px; text-align:right;">${b ?? "—"}</td>
                    <td style="padding:10px; text-align:right;">${p ?? "—"}</td>
                    <td style="padding:10px; text-align:right;">${Number.isFinite(p-b) ? ((p-b)>=0?"+":"") + (p-b) : "—"}</td>
                  </tr>
                `).join("")}
              </tbody>
            </table>
          </div>
        </div>
      `;
    }

    /* ---- CSV Export ---- */
    function exportCSV(){
      const attempts = loadAttempts();
      if(attempts.length === 0){
        alert("No attempts stored on this device yet.");
        return;
      }

      const headers = ["id","attemptType","displayName","startedAt","finishedAt","activeSeconds","cei","sei","ees","gap"];
      const rows = attempts.map(a => {
        const m=a.meta, s=a.scores;
        const vals = [a.id,m.attemptType,m.displayName||"",m.startedAt,m.finishedAt,m.activeSeconds,s.cei,s.sei,s.ees,s.gap];
        return vals.map(v => `"${String(v ?? "").replaceAll('"','""')}"`).join(",");
      });

      const csv = headers.join(",") + "\n" + rows.join("\n");
      const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = `creative-expansion-lab_${new Date().toISOString().slice(0,10)}.csv`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    /* ---- Utils ---- */
    function cryptoRandomId(){
      if(window.crypto && crypto.getRandomValues){
        const buf = new Uint32Array(4);
        crypto.getRandomValues(buf);
        return [...buf].map(x => x.toString(16)).join("-");
      }
      return String(Math.random()).slice(2) + "-" + String(Date.now());
    }
    
    /* ---- Safe Bind Helper ---- */
    function bind(id, handler){
      const el = document.getElementById(id);
      if(!el){
        console.warn("Missing element:", id);
        return;
      }
      el.onclick = handler;
    }

    function flashPressed(el){
      if(!el) return;
      el.classList.add("is-pressed");
      setTimeout(() => el.classList.remove("is-pressed"), 180);
    }

    /* ---- Bind buttons safely ---- */
    bind("startBtn", startLab);
    bind("viewResultsBtn", showStoredResults);
    bind("backBtn", prevRound);
    bind("retakeBtn", () => { resetAttempt(false); showIntro(); });
    bind("backHomeBtn", showIntro);
    bind("exportBtn", exportCSV);
    /*bind("resetAllBtn", resetAll);*/

    /* Timer buttons */
    bind("timerStartBtn", (e) => { flashPressed(e.currentTarget); startActiveTimer(); });
    bind("timerStopBtn",  (e) => { flashPressed(e.currentTarget); stopActiveTimer(); });
    bind("timerResetBtn", (e) => { flashPressed(e.currentTarget); resetActiveTimer(); });
   
    /* Next button */
    if(nextBtn){
      nextBtn.onclick = () => { unlockNext(); nextRound(); };
    }

    /* Manual timer buttons (requires these IDs in cel.html) */
    if(timerStartBtn) timerStartBtn.onclick = startActiveTimer;
    if(timerStopBtn)  timerStopBtn.onclick  = stopActiveTimer;
    if(timerResetBtn) timerResetBtn.onclick = resetActiveTimer;

    /* ---- Init ---- */
    setTimerButtons();
    renderActiveTimerPill();
    showIntro();
  });
})();
